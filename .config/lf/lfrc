# =======================================================================
# ================================ options ==============================
# =======================================================================
set previewer /home/brian/.config/lf/lf_scope.sh
# set previewer /home/brian/.config/lf/scope.sh
# set previewer pistol

# dynamically set number of columns
# cmd recol %{{
#     w=$(tput cols)
#     if [ $w -le 80 ]; then
#         lf -remote "send $id set ratios 1:2"
#     elif [ $w -le 160 ]; then
#         lf -remote "send $id set ratios 1:2:3"
#     else
#         lf -remote "send $id set ratios 1:2:3:5"
#     fi
# }}

# interpreter for shell commands (needs to be POSIX compatible)
set shell zsh

set shellopts '-eu:--shwordsplit'

set ifs "\n"
set filesep "\n"  # default already

set scrolloff 10
set incsearch
set color256
set icons


# =======================================================================
# ================================ commands =============================
# =======================================================================

# asynchronous paste
cmd paste &{{
    load=$(lf -remote 'load')
    mode=$(echo "$load" | sed -n '1p')
    list=$(echo "$load" | sed '1d')
    if [ $mode = 'copy' ]; then
        cp -rn $list .
    elif [ $mode = 'move' ]; then
        mv -n $list .
    fi
    lf -remote 'send load'
    lf -remote 'send clear'
}}

# define a custom 'open' command
cmd open ${{
    case $(file --mime-type $f -b) in
        text/*) $EDITOR $fx;;
        *) for f in $fx; do setsid $OPENER $f > /dev/null 2> /dev/null & done;;
    esac
}}

# define a custom 'rename' command without prompt for overwrite
# cmd rename %[ -e $1 ] && printf "file exists" || mv $f $1
# map r push :rename<space>

# make sure trash folder exists
# %mkdir -p ~/.trash

# move current file or selected files to trash folder
cmd trash %trash-put $fx

# extract the current file with the right command
cmd extract ${{
    set -f
    case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f;;
        *.tar.gz|*.tgz) tar xzvf $f;;
        *.tar.xz|*.txz) tar xJvf $f;;
        *.zip) unzip $f;;
        *.rar) unrar x $f;;
        *.7z) 7z x $f;;
    esac
}}

cmd mkdir %mkdir -p "$@"
cmd touch %touch "$@"

# compress current file or selected files with tar and gunzip
cmd tar ${{
    set -f
    mkdir $1
    cp -r $fx $1
    tar czf $1.tar.gz $1
    rm -rf $1
}}

# compress current file or selected files with zip
cmd zip ${{
    set -f
    mkdir $1
    cp -r $fx $1
    zip -r $1.zip $1
    rm -rf $1
}}

cmd fzf_jump ${{
   export FZF_DEFAULT_COMMAND='fd --type directory --follow --exclude .git --color=always --hidden' 
   res="$(fzf)"
   export FZF_DEFAULT_COMMAND='fd --type file --follow --exclude .git --color=always --hidden'
   cmd="cd"                                                       
lf -remote "send $id $cmd \"$res\""
}}

# cmd fzf_open ${{
#    res="$(fzf)"
#    if [ -n "$res" ]; then
#       cmd="rifle"
#       lf -remote "send $id $cmd \"$res\""
#    fi
# }}

cmd fzf_jump_files ${{
   res="$(fzf)"
   cmd="select"
   lf -remote "send $id $cmd \"$res\""
}}

cmd Link %{{
	lf -remote 'load' | while read file; do
		if [ ! -n "${mode+1}" ]; then
			mode="$file"
			continue
		fi
		files+=("$file")
	done
	if [ "${#files[@]}" -le 1 ]; then
		lf -remote "send $id echo no files to link"
		exit 0
	fi
	# symbolicly copy mode is indicating a soft link
	if [[ "$mode" == copy ]]; then
		ln -sr $files -t .
	# while a move mode is indicating a hard link
	elif [[ "$mode" == move ]]; then
		ln $files -t .
	fi
}}

# use rifle for now
# cmd rifle ${{
#    rifle $f
# }}

# open things with rifle
# cmd open rifle $f

cmd video_preview ${{
    CACHE=$(mktemp /tmp/thumb_cache.XXXXX)
    ffmpegthumbnailer -i "$f" -o $CACHE -s 0
    $HOME/.config/lf/draw_img.sh $CACHE && rm $CACHE
}}

cmd bulk-rename ${{
    old=$(mktemp)
    new=$(mktemp)
    [ -n $fs ] && fs=$(ls)
    printf "$fs\n" > $old
    printf "$fs\n" > $new
    $EDITOR $new
    [ $(cat $new | wc -l) -ne $(cat $old | wc -l) ] && exit
    paste $old $new | while read names; do
	src=$(printf $names | cut -f1)
	dst=$(printf $names | cut -f2)
	[ $src = $dst ] && continue
	[ -e $dst ] && continue
	mv $src $dst
    done
    rm $old $new
    lf -remote "send $id unselect"
}}

# =======================================================================
# ================================ mappings =============================
# =======================================================================

map <c-e> :fzf_jump
map <c-p> :fzf_open
map <c-t> :fzf_jump_files

# export FZF_DEFAULT_COMMAND="fd --type file --follow --exclude .git --color=always --hidden"

map . set hidden!
map gh :cd ~


map a push :touch<space>
map A push :mkdir<space>

map D trash
map <delete> delete
map <enter> shell

# execute current file (must be executable)
map x $$f
map X !$f

# dedicated keys for file opener actions
map o &mimeopen $f
map O $mimeopen --ask $f

map P :Link

map - $$HOME/.config/lf/draw_img.sh $f
map + :video_preview

map R :bulk-rename

# ranger like rename mappings

# Unmap the default binding
# map r

# # Rename the file with a completely different name
# map rc push :rename<space>

# # Edit the current filename
# map ra ${{
# 	# get 'basename' of the selection
# 	filename="${f##*/}"
# 	# quote it so we won't deal with quotes in the lf -remote command
# 	filename="$(printf '%q' "$filename")"
# 	filename="${filename// /<space>}"
# 	lf -remote "send $id push :rename<space>$filename"
# }}

# # Edit filename before the extension
# map re ${{
# 	# get 'basename' of the selection
# 	filename="${f##*/}"
# 	# quote it so we won't deal with quotes in the lf -remote command
# 	filename="$(printf '%q' "$filename")"
# 	filename="${filename// /<space>}"
# 	lf -remote "send $id push :rename<space>$filename<a-b><c-b>"
# }}
